        - 
        - using LinearAlgebra
        - using SparseArrays
        - 
        - export ham_fd, LUT, redef1, redef2, redef3, U_fe
        - 
        - function ham_fd(ltc::Lattice3D, Ea::Real, Eb::Real)
        0     @assert ltc.U == 2
      528     return spdiagm(0 => repeat([Float64(Ea), Float64(Eb)], ltc.L*ltc.M*ltc.N))
        - end
        - 
        - function LUT(ltc::Lattice3D, θ::Real)
        0     num_sites = ltc.L*ltc.M*ltc.N*ltc.U
        0     cos_θ = cospi(θ)
        0     sin_θ = sinpi(θ)
      720     I = Int64[]; J = Int64[]; V = Float64[]
        0     for l in 1:ltc.L, m in 1:ltc.M, n in 1:ltc.N
   197952         push!(I, index(ltc, (l,m,n,1)))
   197952         push!(J, index(ltc, (l,m,n,1)))
   197952         push!(V, cos_θ )
        - 
        0         push!(I, index(ltc, (l,m,n,2)))
        0         push!(J, index(ltc, (l,m,n,1)))
        0         push!(V, -sin_θ )
        - 
        0         push!(I, index(ltc, (l,m,n,1)))
        0         push!(J, index(ltc, (l,m,n,2)))
        0         push!(V, sin_θ )
        - 
        0         push!(I, index(ltc, (l,m,n,2)))
        0         push!(J, index(ltc, (l,m,n,2)))
        0         push!(V, cos_θ )
        -     end
      240     return sparse(I, J, V, num_sites, num_sites)
        - 
        - end
        - 
        - function redef1(ltc::Lattice3D)
        0     num_sites = ltc.L*ltc.M*ltc.N*ltc.U
      720     I = Int64[]; J = Int64[]; V = Float64[]
        0     for l in 1:ltc.L, m in 1:ltc.M, n in 1:ltc.N
    99456         push!(I, index(ltc, (l,m,n,1)))
    99456         push!(J, index(ltc, (l,m,n,1)))
    99456         push!(V, 1)
        - 
        0         push!(I, index(ltc, (l,m,n,2)))
        0         push!(J, index(ltc, (l+1,m,n,2)))
        0         push!(V, 1)
        -     end
      240     return sparse(I, J, V, num_sites, num_sites)
        - end
        - 
        - function redef2(ltc::Lattice3D)
        0     num_sites = ltc.L*ltc.M*ltc.N*ltc.U
      720     I = Int64[]; J = Int64[]; V = Float64[]
        0     for l in 1:ltc.L, m in 1:ltc.M, n in 1:ltc.N
    99456         push!(I, index(ltc, (l,m,n,1)))
    99456         push!(J, index(ltc, (l,m,n,1)))
    99456         push!(V, 1)
        - 
        0         push!(I, index(ltc, (l,m,n,2)))
        0         push!(J, index(ltc, (l,m+1,n,2)))
        0         push!(V, 1)
        -     end
      240     return sparse(I, J, V, num_sites, num_sites)
        - end
        - 
        - function redef3(ltc::Lattice3D)
        0     num_sites = ltc.L*ltc.M*ltc.N*ltc.U
      720     I = Int64[]; J = Int64[]; V = Float64[]
        0     for l in 1:ltc.L, m in 1:ltc.M, n in 1:ltc.N
    99456         push!(I, index(ltc, (l,m,n,1)))
    99456         push!(J, index(ltc, (l,m,n,1)))
    99456         push!(V, 1)
        - 
        0         push!(I, index(ltc, (l,m,n,2)))
        0         push!(J, index(ltc, (l,m,n+1,2)))
        0         push!(V, 1)
        -     end
      240     return sparse(I, J, V, num_sites, num_sites)
        - end
        - 
        - function U_fe(ltc::Lattice3D, θ::Real)
        0     U1 = LUT(ltc,θ)
        0     T1 = redef1(ltc)
        0     T2 = redef2(ltc)
        0     T3 = redef3(ltc)
        0     return U1*T3*U1*T2*U1*T1*U1
        - end
        - 
        - function ham_fe(ltc::Lattice3D, Ea, Eb, θ::Real)
        -     U = U_fe(ltc, θ)
        -     H_fd = ham_fd(ltc, Ea, Eb)
        -     H_fe = U*H_fd*U'
        -     return H_fe, U
        - end
